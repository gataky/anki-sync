import json
from typing import Hashable, cast

import attr
import pandas

from anki_sync.core.models.constants import (
    ANKI_NOTE_MODEL,
    Gender,
    Number,
    PartOfSpeech,
    Person,
    Tense,
)
from anki_sync.core.models.genanki import Note
from anki_sync.core.sql import AnkiDatabase
from anki_sync.utils.guid import generate_guid


@attr.s(auto_attribs=True, frozen=True)
class AudioMeta:

    phrase: str
    filename: str


@attr.s(auto_attribs=True, init=False)
class Word:

    # Every note will have these fields
    english: str
    greek: str

    # Optional fields for a word.
    definitions: str = ""
    synonyms: str = ""
    antonyms: str = ""
    etymology: str = ""
    notes: str = ""

    part_of_speech: PartOfSpeech = attr.ib(
        default=PartOfSpeech.UNKNOWN, converter=PartOfSpeech
    )
    gender: Gender = attr.ib(default=Gender.UNKNOWN, converter=Gender)
    person: Person = attr.ib(default=Person.UNKNOWN, converter=Person)
    tense: Tense = attr.ib(default=Tense.UNKNOWN, converter=Tense)
    number: Number = attr.ib(default=Number.UNKNOWN, converter=Number)

    # The audio filename
    audio_filename: str = ""

    # meta fields used to sync between the two systems.
    #
    # GUID is used to correctly apply updates to notes within Anki.
    # we create the GUID on new cards and tell Anki what it is so
    # in the future we can correctly target the same card for updates
    # if there are any.
    guid: str = attr.ib(factory=lambda: generate_guid(10))
    # ID is the ID generated by Anki and will be populated by Anki.
    # We keep reference of it so we can correctly copy over the history
    # of the card.
    id: int | None = None
    # tags are metadata attached to a card to help organize.
    tags: list[str] = attr.ib(factory=list)

    def __init__(self, **kwargs):
        self._exists_in_anki: bool = False
        self._google_sheet_cell: str = ""

        transformed_kwargs = {
            key.lower().replace(" ", "_"): value for key, value in kwargs.items()
        }

        cls_fields = {f.name for f in attr.fields(self.__class__)}
        init_kwargs = {k: v for k, v in transformed_kwargs.items() if k in cls_fields}

        self.__attrs_init__(**init_kwargs)

    @classmethod
    def from_sheets(cls, row: tuple[Hashable, pandas.Series]):
        index, df = row
        index = cast(int, index)

        data = df.to_dict()
        data["guid"] = df.guid

        obj = cls(**data)
        obj.process_tags(df)
        obj.process_audio_filename()

        obj._google_sheet_cell = f"A{index+2}"
        return obj

    @classmethod
    def from_ankidb(cls, note: pandas.DataFrame):
        data = note.data
        if not data:
            return None
        data = json.loads(data)
        data["guid"] = note.name
        data["id"] = int(note.id)

        obj = cls(**data)
        return obj

    def to_note(self, old_db_conn: AnkiDatabase) -> Note:
        self.id, self._exists_in_anki = old_db_conn.get_note_id_by_guid(self.guid)
        if self._exists_in_anki is False:
            self.guid = generate_guid()

        # NOTE: the values here much match the fields called out here ANKI_NOTE_MODEL_FIELDS
        note_fields = [
            self.english,
            self.greek,
            self.audio_filename,
            f"{self.part_of_speech.value} {self.gender.value}",
            (
                self.definitions
                if not self.definitions
                else "<div>" + self.definitions.replace("\n", "</div><div>") + "</div>"
            ),
            self.synonyms,
            self.antonyms,
            self.etymology,
            self.notes,
        ]

        tags = self.get_note_tags()
        return Note(
            model=ANKI_NOTE_MODEL,
            guid=self.guid,
            id=self.id,
            fields=note_fields,
            tags=tags,
            old_db_conn=old_db_conn,
        )

    def exists_in_anki(self):
        return self._exists_in_anki

    def get_note_tags(self) -> list[str]:
        tags_list = [f"grammar::{self.part_of_speech.value}"]
        current_hierarchy_parts = []
        for cell_content_raw in self.tags:
            cell_content = str(cell_content_raw or "").strip()
            if not cell_content:
                break
            current_hierarchy_parts.append(cell_content.replace(" ", "\u00a0"))
            tags_list.append("::".join(current_hierarchy_parts))
        return sorted(list(set(tags_list)))

    def get_audio_meta(self) -> AudioMeta:
        return AudioMeta(phrase=self.greek, filename=self.audio_filename)

    def process_tags(self, series: pandas.Series) -> list[str]:
        """Process tags from the input series."""
        tag_columns = [col for col in series.index if "tag" in str(col).lower()]
        tags = [series[col] for col in tag_columns if series[col]]
        self.tags = tags
        return self.tags

    def process_audio_filename(self) -> str:
        self.audio_filename = f"{self.greek}.mp3"
        return self.audio_filename
