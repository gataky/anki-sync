import json
from enum import Enum
from typing import Hashable, cast

import attr
import pandas

from anki_sync.core.models.audio import AudioMeta
from anki_sync.core.models.note import Note
from anki_sync.core.sql import AnkiDatabase
from anki_sync.utils.guid import generate_guid
from anki_sync.core.models.constants import ANKI_NOTE_MODEL


class PartOfSpeech(Enum):
    ADJECTIVE = "adjective"
    ADVERB = "adverb"
    CONJUNCTION = "conjunction"
    NOUN = "noun"
    PREPOSITION = "preposition"
    VERB = "verb"
    UNKNOWN = "unknown"


class Gender(Enum):
    MASCULINE = "masculine"
    FEMININE = "feminine"
    NEUTER = "neuter"
    UNKNOWN = ""


class Person(Enum):
    FIRST = "1st"
    SECOND = "2nd"
    THIRD = "3rd"
    UNKNOWN = ""


class Number(Enum):
    SINGULAR = "singular"
    PLURAL = "plural"
    UNKNOWN = ""


class Tense(Enum):
    UNKNOWN = ""


@attr.s(auto_attribs=True, init=False)
class BaseWord:

    # Every note will have these fields
    english: str
    greek: str

    # The part of speech this word belongs to. The value is shown here
    # to make it easier to see all fields available but is actually set
    # in the sub class.
    part_of_speech: PartOfSpeech

    # Optional fields for a word.
    definitions: str = ""
    synonyms: str  = ""
    antonyms: str = ""
    etymology: str = ""
    notes: str = ""

    # TODO: How do we convert the input into an enum?
    gender: Gender = Gender.UNKNOWN
    person: Person = Person.UNKNOWN
    tense: Tense = Tense.UNKNOWN
    number: Number = Number.UNKNOWN

    # The audio filename
    audio_filename: str = ""

    # meta fields used to sync between the two systems.
    #
    # GUID is used to correctly apply updates to notes within Anki.
    # we create the GUID on new cards and tell Anki what it is so
    # in the future we can correctly target the same card for updates
    # if there are any.
    guid: str = attr.ib(factory=lambda: generate_guid(10))
    # ID is the ID generated by Anki and will be populated by Anki.
    # We keep reference of it so we can correctly copy over the history
    # of the card.
    id: int | None = None
    # tags are metadata attached to a card to help organize.
    tags: list[str] = attr.ib(factory=list)

    def __init__(self, **kwargs):
        self._exists_in_anki: bool = False
        self._google_sheet_cell: str = ""
        self.init(self, **kwargs)

    @staticmethod
    def init(cls, **kwargs):
        transformed_kwargs = {
            key.lower().replace(" ", "_"): value for key, value in kwargs.items()
        }

        cls_fields = {f.name for f in attr.fields(cls.__class__)}
        init_kwargs = {k: v for k, v in transformed_kwargs.items() if k in cls_fields}

        cls.__attrs_init__(**init_kwargs)

    @classmethod
    def from_sheets(cls, row: tuple[Hashable, pandas.Series]):
        index, df = row
        index = cast(int, index)

        data = df.to_dict()
        data["guid"] = df.guid

        obj = cls(**data)
        obj.process_tags(df)
        obj.process_audio_filename()

        obj._google_sheet_cell = f"A{index+2}"
        return obj

    @classmethod
    def from_ankidb(cls, note: pandas.DataFrame):
        data = note.data
        if not data:
            return None
        data = json.loads(data)
        data["guid"] = note.name
        data["id"] = int(note.id)

        obj = cls(**data)
        return obj

    def to_note(self, old_db_conn: AnkiDatabase) -> Note:
        self.id, self._exists_in_anki = old_db_conn.get_note_id_by_guid(self.guid)
        if self._exists_in_anki is False:
            self.guid = generate_guid()

        # NOTE: the values here much match the fields called out here ANKI_NOTE_MODEL_FIELDS
        note_fields = [
            self.english,
            self.greek,
            self.audio_filename,
            f"{self.part_of_speech.value} {self.gender}",
            self.definitions,
            self.synonyms,
            self.antonyms,
            self.etymology,
            self.notes,
        ]

        tags = self.get_note_tags()
        return Note(
            model=ANKI_NOTE_MODEL,
            guid=self.guid,
            id=self.id,
            fields=note_fields,
            tags=tags,
            old_db_conn=old_db_conn,
        )

    def exists_in_anki(self):
        return self._exists_in_anki

    def get_note_tags(self) -> list[str]:
        tags_list = [f"grammar::{self.part_of_speech.value}"]
        current_hierarchy_parts = []
        for cell_content_raw in self.tags:
            cell_content = str(cell_content_raw or "").strip()
            if not cell_content:
                break
            current_hierarchy_parts.append(cell_content.replace(" ", "\u00a0"))
            tags_list.append("::".join(current_hierarchy_parts))
        return sorted(list(set(tags_list)))

    def get_audio_meta(self) -> AudioMeta:
        return AudioMeta(phrase=self.greek, filename=self.audio_filename)

    def process_tags(self, series: pandas.Series) -> list[str]:
        # process tags
        tag_index: int = -1
        if "tag" in series:
            tag_index = cast(int, series.index.get_loc("tag"))

        tags = series.iloc[tag_index:].tolist() if tag_index >= 0 else []
        self.tags = list(filter(lambda x: x, tags))
        return self.tags

    def process_audio_filename(self) -> str:
        self.audio_filename = f"{self.greek}.mp3"
        return self.audio_filename


@attr.s(auto_attribs=True, init=False)
class Adjective(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.ADJECTIVE


@attr.s(auto_attribs=True, init=False)
class Adverb(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.ADVERB


@attr.s(auto_attribs=True, init=False)
class Conjunction(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.CONJUNCTION


@attr.s(auto_attribs=True, init=False)
class Noun(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.NOUN


@attr.s(auto_attribs=True, init=False)
class Preposition(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.PREPOSITION


@attr.s(auto_attribs=True, init=False)
class Verb(BaseWord):
    part_of_speech: PartOfSpeech = PartOfSpeech.VERB
